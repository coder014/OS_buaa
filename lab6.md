# Lab6 实验报告

## 思考题

### Thinking 6.1

```c
case 0: /* 子进程 - 作为管道的写者*/
	close(fildes[0]); /* 关闭不用的读端*/
	...... /* 向管道中写数据*/
	close(fildes[1]); /* 写入结束，关闭写端*/
	exit(EXIT_SUCCESS);

default: /* 父进程 - 作为管道的读者*/
	close(fildes[1]); /* 关闭不用的写端*/
	...... /* 从管道中读数据*/
	close(fildes[0]); /* 读取结束，关闭读端*/
	exit(EXIT_SUCCESS);
```

### Thinking 6.2

与`fork`类似，`dup()`函数的竞争出现在增加fd与pipe的引用计数的过程中。有如下代码：

```c
// 子进程
	read(p[0], buf, sizeof(buf));

// 父进程    
	dup(p[0], newfd);
	write(p[1], "Hello", 5);
```

- 假设fork结束后，子进程先执行。时钟中断产生在read之前，此时父进程开始执行。
- 父进程在dup\(p\[0\]\)过程中，已经完成了对p\[0\]的映射，此时发生中断，还没有来得及完成p\[0\]对pipe的映射。
- 此时子进程执行read函数，发现pageref\(p\[0\]\)与pageref\(pipe\)都是2, 认为此时写端关闭。

### Thinking 6.3

在MOS中，用户进程的非原子性操作主要是时钟中断引发进程切换造成的。而在syscall过程中，系统工作在内核态，时钟中断被屏蔽，内核也没有统一时间处理多个进程的syscall的能力，因此系统调用是原子操作。

### Thinking 6.4

* 可以，根据管道未关闭时的不等式关系$\textrm{pageref}(pipe) > \textrm{pageref}(fd)$。只需先解除fd的映射，后解除pipe的映射即可。
* 会，参考*Thinking 6.2*。

### Thinking 6.5

`elf_load_seg()`函数读取ELF的程序段头，获取段头中描述的该段需映射到的虚拟地址与占用空间以及该段的数据在文件中的占用空间。然后调用`map_page()`回调函数映射到内存，其中对于超出文件空间的地址，回调函数的`src`参数为`NULL`；具体地，回调函数的进程加载实现`load_icode_mapper()`函数中，当`src == NULL`时，直接分配一页物理内存并映射。由于物理页面在分配时会自动将对应内存填充为0，因此加载后的`bss`段初始值为0。

### Thinking 6.6

`init`进程启动时会调用`opencons()`函数打开终端，此时由于第一次调用文件描述符相关操作，因此fd号必为0，作为标准输入；并dup至1，作为标准输出。此后随着fork“继承”至所有子进程。

### Thinking 6.7

在MOS中我们用到的shell命令是外部命令。`cd`的作用是改变**当前的**工作目录，如果是外部命令则只能改变子shell的工作目录，无法改变当前shell的工作目录。

### Thinking 6.8

* 两次。`ls.b`和`cat.b`。
* 四次。`ls.b`、`cat.b`、fork出的处理管道右侧命令的`sh.b`、初始的`sh.b`。

## 难点分析

实验难点一在于管道的原理与管道关闭的判断，图解见指导书图6.1、6.2。

二在于部分竞争情况的解决。

三是用户进程的初始栈空间的布局与构建流程，图解指导书图6.3。

四是shell的启动与工作流程，图解指导书图6.4、6.5。

## 实验体会

Lab6的实验带我最终完成了一个可以与使用者进行简单交互的MOS系统。操作系统实验到此告一段落，虽然路途中困难重重，但最终motd跳出的那一刻，还是觉得一学期的学习值得，且收获颇丰。

