# Lab4 实验报告

## 思考题

### Thinking 4.1

* 内核在保存现场的时候是如何避免破坏通用寄存器的？
  * 在异常`handler`进入时使用`SAVE_ALL`宏保存上下文时，利用了`k0`、`k1`两个寄存器来暂存其他通用寄存器（如`sp`）的信息，避免破坏通用寄存器。
* 系统陷入内核调用后可以直接从当时的`$a0-$a3`参数寄存器中得到用户调用`msyscall`留下的信息吗？
  * 可以。
* 我们是怎么做到让`sys`开头的函数“认为”我们提供了和用户调用`msyscall`时同样的参数的？
  * 在`do_syscall`函数中取出陷入内核态时保存的寄存器上下文中的`a0`-`a3`等寄存器与栈空间中的参数并调用对应处理函数。
* 内核处理系统调用的过程对`Trapframe`做了哪些更改？这种修改对应的用户态的变化是什么？
  * 处理`EPC`（可能+4，返回时直接返回到下一条指令），将内核态系统调用函数的返回值存入`v0`寄存器对应的数据区域。在用户态恢复上下文时可以获取到系统调用的“返回值”，且继续正常执行指令。

### Thinking 4.2

预防`envid`冲突，否则在传入一个不存在的`envid`时可能会正常返回一个`env`控制块。

### Thinking 4.3

在`mkenvid`中，有如下语句：

```c
static u_int i = 0;
return ((++i) << (1 + LOG2NENV)) | (e - envs);
```

保证了高位部分始终有为1的位，因此不会返回0，即不存在实际为0的`envid`。在系统调用或IPC过程中，用户可能需要用0来指代当前进程（自身进程），因此必须保证不存在实际为0的`envid`，以便给0赋予特殊意义。

### Thinking 4.4

C

### Thinking 4.5

虚拟地址范围从$0$到$USTACKTOP$的页都有可能需要映射。具体地，只读页与具有`PTE_LIBRARY`权限位的页不需要映射，其余页均需要映射。

### Thinking 4.6

* `vpt`和`vpd`的作用是什么？怎样使用它们？
  * 在用户空间中访问进程自身页目录或页表。C语言中可以通过`vpt[vpn]`或`vpd[vpdn]`来访问。
* 从实现的角度谈一下为什么进程能够通过这种方式来存取自身的页表？
  * 内核将进程的虚拟地址UVPT映射到相关储存页表的物理内存区域；`vpt`与`vpd`则是两个宏，指向对应的内存地址。
* 它们是如何体现自映射设计的？
  * `vpd`本身处于`vpt`段中，说明页目录本身处于其所映射的页表中的一个页面里面。所以这两个指针的设计中运用了自映射。
* 进程能够通过这种方式来修改自己的页表项吗？
  * 不能，映射时的权限位规定了其是只读的。

### Thinking 4.7

* 这里实现了一个支持类似于“异常重入”的机制，而在什么时候会出现这种“异常重入”？
  * 在用户进程发生写时复制引发的缺页异常并进行处理时，可能会再次发生缺页异常，从而出现“中断重入”。
* 内核为什么需要将异常的现场`Trapframe`复制到用户空间？
  * 在我们的操作系统设计中，缺页错误处理交由用户进程，用户进程在处理过程中可能需要读取`Trapframe`的各项内容，同时在处理结束后同样由用户进程恢复现场，因此要将`Trapframe`复制到用户空间。

### Thinking 4.8

更灵活，降低内核设计的复杂程度与内核工作量，体现了微内核的设计思想。

### Thinking 4.9

* 为什么需要将`syscall_set_tlb_mod_entry`的调用放置在`syscall_exofork`之前？
  * 需要提前注册异常处理函数，否则在用户的fork函数内就有可能立刻引发缺页异常。
* 如果放置在写时复制保护机制完成之后会有怎样的效果？
  * COW相关缺页异常处理出错。

## 难点分析

实验难点一在于系统调用过程中对**陷入内核态**的理解，与寄存器上下文的保存与恢复流程，图解见指导书图4.1、4.2与代码中`SAVE_ALL`、`RESTORE_SOME`相关宏。

二在于IPC机制，主要是其阻塞/等待时与进程调度相关的配合处理过程，图解见指导书图4.3。

三是Fork，尤其是COW（写时复制机制），图解见指导书图4.4、4.5。

## 实验体会

Lab4的实验带我了解了MOS系统的系统调用、IPC机制与Fork机制的执行过程与原理。一个微型操作系统已初具雏形。

